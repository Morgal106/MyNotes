---
tags : [ 编程语言, Rust ]
---

## 生命周期的概念

生命周期，简言之就是引用的存活时间，编译器大多时候可以自动推导，但有些时候需要手动标注

- 往往在函数有多个引用参数，且返回值是引用时，编译器无法确定新引用的生命周期，因此需要显式地标注
- 在结构体中使用引用也需要标注生命周期

## 生命周期的作用

生命周期一个很重要的作用就是避免了悬垂引用

### 悬垂引用

```Rust
{ 
    let r; 
	{ 
		let x = 5; 
		r = &x; 
	} 
	println!("r: {}", r); 
}
```

上述代码中，r引用了x，但x在他所在的块结束时被drop，而r在之后又被使用，此时r引用的是一块空的内存地址，这种现象叫做悬垂引用，或者叫悬垂指针

## 借用检查器

为了保证不会出现悬垂引用，Rust使用借用检查器来保证生命周期的正确性，当检查到错误的引用时会报错

## 生命周期标注

> [!note]
> 标注生命周期并不会改变实际的作用域

### 函数中的生命周期

```Rust
fn func<'a>(v1: &'a vec, v2: &'a vec) -> &'a vec{}
```

生命周期标注表明，该引用活的比标注的生命周期要长（Outlive），上述生命周期标注，意味着返回值的生命周期等于两个参数中的较小者

```Rust
fn func<'a: 'b, 'b>(v1: &'a vec, v2: &'b vec) -> &'a vec{}
```

当两个参数标注的生命周期不同时，可以使用`:`运算符表示生命周期的关系`'a: 'b`表示生命周期 'a outlives 'b

### 结构体中的生命周期

```Rust
struct List<'a> {
    elem: i32,
    next: &'a List
}
```

## 生命周期消除规则

在Rust 1.0版本之前，所有引用都要手动标注生命周期，大量的重复代码过于繁琐，因此新增了生命周期消除规则。

函数的参数的生命周期被称为输入生命周期，返回值的生命周期被称为输出生命周期

1. 每一个参数都有自己的生命周期
2. 如果只有一个输入生命周期，该生命周期会被赋给所有的输出生命周期
3. 若存在多个生命周期，且其中一个生命周期是 `&self` 或者 `&mut self` 该生命周期会被赋给所有输出生命周期

## 方法中的生命周期

因为省略规则三的存在，方法中的生命周期往往不需要手动标注

```Rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

## 无界生命周期

定义裸指针，并在unsafe块中再引用，此时新的引用的生命周期是凭空产生的，称为无界生命周期，无界生命周期没有任何约束，可大可小，需要谨慎使用

## NLL (Non-Lexical Lifetime)

在早期版本的 Rust 中引用的生命周期持续到当前块的结束，但是当不可变引用在作用域内不再使用时，因为借用规则的存在，无法创建新的可变引用

在新版本（1.31以后）中，引用的生命周期将会持续到最后一次被使用时

```Rust
let mut u = 0i32;
let mut v = 1i32;
let mut w = 2i32;

// lifetime of `a` = α ∪ β ∪ γ
let mut a = &mut u;     // --+ α. lifetime of `&mut u`  --+ lexical "lifetime" of `&mut u`,`&mut u`, `&mut w` and `a`
use(a);                 //   |                            |
*a = 3; // <-----------------+                            |
...                     //                                |
a = &mut v;             // --+ β. lifetime of `&mut v`    |
use(a);                 //   |                            |
*a = 4; // <-----------------+                            |
...                     //                                |
a = &mut w;             // --+ γ. lifetime of `&mut w`    |
use(a);                 //   |                            |
*a = 5; // <-----------------+ <--------------------------+
```

## Reborrow 再借用

再借用即对一个引用的解引用的引用，此时新的引用适用于新的借用检查，且原本的引用在再借用期间无法使用，它被视为是解引用的引用

```Rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn move_to(&mut self, x: i32, y: i32) {
        self.x = x;
        self.y = y;
    }
}

fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &mut p;
    let rr: &Point = &*r;

    println!("{:?}", rr);
    r.move_to(10, 10);
    println!("{:?}", r);
}
```

在上面的代码中，在p的可变引用r存活期间，声明了一个对r的解引用的不可变引用


